# Fibonacci Sequence (calculates first 10 Fibonacci numbers)
addi x1, x0, 10       # Number of Fibonacci numbers to generate
addi x2, x0, 0        # Fib(0) = 0
addi x3, x0, 1        # Fib(1) = 1
addi x4, x0, 2        # Counter starting from 2
addi x10, x0, 0       # Memory pointer for storing results
sd x2, 0(x10)         # Store Fib(0)
addi x10, x10, 8      # Increment by 8 for doubleword
sd x3, 0(x10)         # Store Fib(1)
addi x10, x10, 8      # Increment by 8 for doubleword
add x5, x2, x3        # Calculate next Fibonacci number looping starts here
sd x5, 0(x10)         # Store result in memory
addi x10, x10, 8      # Increment by 8 for doubleword
addi x4, x4, 1        # Increment counter
add x2, x3, x0        # Shift values: x2 = x3
add x3, x5, x0        # Shift values: x3 = x5
sub x6, x1, x4        # Calculate x1 - x4
beq x6, x0, 4         # If counter == limit, exit
beq x0, x0, -16       # Else continue loop
addi x11, x0, 0 



# Iterative sum (replaces factorial since mul isn't available)
addi x1, x0, 5        # Sum numbers from 1 to 5
addi x2, x0, 0        # Initialize result to 0
addi x3, x0, 1        # Counter starting at 1
add x2, x2, x3        # Add counter to result and looping starts here
addi x3, x3, 1        # Increment counter
sub x4, x1, x3        # Calculate x1 - x3
addi x4, x4, 1        # Adjust comparison
beq x4, x0, 4         # If counter > limit, exit
beq x0, x0, -10       # Else continue loop
addi x10, x0 ,0


# Array sum (sum of array elements)
addi x1, x0, 0        # Initialize array base address
addi x2, x0, 5        # Array size
addi x3, x0, 0        # Initialize sum to 0
addi x4, x0, 0        # Loop counter
ld x5, 0(x1)          # Load array element loping here
add x3, x3, x5        # Add to running sum
addi x1, x1, 8        # Move to next array element (doubleword)
addi x4, x4, 1        # Increment counter
sub x6, x2, x4        # Calculate x2 - x4
beq x6, x0, 4         # If counter == size, exit
beq x0, x0, -12       # Else continue loop
addi x10, x0, 0


# Linear search (adapted for beq only)
addi x1, x0, 100      # Array base address
addi x2, x0, 10       # Array size
addi x3, x0, 7        # Value to find
addi x4, x0, 0        # Loop counter
addi x5, x0, -1       # Result index (starts at -1)
ld x6, 0(x1)          # Load array element looping from here
sub x7, x6, x3        # Calculate x6 - x3
beq x7, x0, 12        # If diff == 0 (equal), jump to found
addi x1, x1, 8        # Move to next array element (doubleword)
addi x4, x4, 1        # Increment counter
sub x7, x2, x4        # Calculate x2 - x4
beq x7, x0, 6         # If counter == size, exit
beq x0, x0, -14       # Else continue loop
add x5, x4, x0        # Store found index
addi x10, x0, 0       # Continue execution


# Even/odd checker for numbers 1-5
addi x1, x0, 1        # Start with 1
addi x2, x0, 5        # End at 5
addi x3, x0, 0        # Current number
addi x4, x0, 0        # Even count
addi x5, x0, 0        # Odd count
addi x3, x3, 1        # Increment number eve odd loop
addi x6, x3, 0        # Copy to x6
andi x6, x6, 1        # Check least significant bit
beq x6, x0, 4         # If LSB is 0, number is even
addi x5, x5, 1        # Increment odd count
beq x0, x0, 4         # Continue to next number
addi x4, x4, 1        # Increment even count
sub x6, x2, x3        # Check if we've reached the end
beq x6, x0, 4         # If counter == limit, exit
beq x0, x0, -16 52    # Else continue loop
addi x11, x0, 0       #exit condition
